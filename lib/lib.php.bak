<?php
// This file is part of Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Collection of useful functions and constants
 *
 * @package    block_dukreminder
 * @copyright  gtn gmbh <office@gtn-solutions.com>
 * @author       Florian Jungwirth <fjungwirth@gtn-solutions.com>
 * @ideaandconcept Gerhard Schwed <gerhard.schwed@donau-uni.ac.at>
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */
define('COMPLETION_STATUS_ALL', 0);
define('COMPLETION_STATUS_COMPLETED', 1);
define('COMPLETION_STATUS_NOTCOMPLETED', 2);

define('PLACEHOLDER_COURSENAME', '###coursename###');
define('PLACEHOLDER_USERNAME', '###username###');
define('PLACEHOLDER_USERMAIL', '###usermail###');
define('PLACEHOLDER_USERCOUNT', '###usercount###');
define('PLACEHOLDER_USERS', '###users###');

define('CRITERIA_COMPLETION', 250000);
define('CRITERIA_ENROLMENT', 250001);
define('CRITERIA_ALL', 250002);

// SHOULD BE CHANGED.
define('EMAIL_DUMMY', 2);

/**
 * Build navigation tabs
 * @param integer $courseid
 */
function block_dukreminder_build_navigation_tabs($courseid) {

    $rows[] = new tabobject('tab_course_reminders',
        new moodle_url('/blocks/dukreminder/course_reminders.php',
        array("courseid" => $courseid)),
        get_string('tab_course_reminders', 'block_dukreminder'));
    $rows[] = new tabobject('tab_new_reminder',
        new moodle_url('/blocks/dukreminder/new_reminder.php',
        array("courseid" => $courseid)),
        get_string('tab_new_reminder', 'block_dukreminder'));
    return $rows;
}

/**
 * Init Js and CSS
 * @return nothing
 */
function block_dukreminder_init_js_css() {

}
/**
 * This function gets all the pending reminder entries. An entry is pending
 * if dateabsolute is set and it is not sent yet (sent = 0)
 * OR
 * if daterelative is set
 *
 * @return array $entries
 */
function block_dukreminder_get_pending_reminders() {
    global $DB;
    $entries = $DB->get_records('block_dukreminder', array('sent' => 0));
    $now = time();

    $entries = $DB->get_records_select('block_dukreminder',
        "(sent = 0 AND dateabsolute > 0 AND dateabsolute < $now) OR (dateabsolute = 0 AND daterelative > 0)");

    // START modification by G. Schwed
    // Check for non existing (deleted) courses.
    foreach ($entries as $entry) {
        $course = $DB->get_record('course', array('id' => $entry->courseid));
        if ($course === FALSE) {
            mtrace("... course $entry->courseid does not exist (perhaps deleted) => skipped<br/>"); // Schwed debug
            unset($entries[$entry->id]);
        }
    }
    // END modification by G. Schwed

    mtrace("... " . count($entries) . " pending reminder(s) found<br/>"); // Schwed debug
    return $entries;
}

/**
 * Replace placeholders
 * @param string $text
 * @param string $coursename
 * @param string $username
 * @param string $usermail
 * @param string $users
 * @param string $usercount
 * @return nothing
 */
function block_dukreminder_replace_placeholders($text, $coursename = '', $username = '',
            $usermail = '', $users = '', $usercount = '') {

    $text = str_replace(PLACEHOLDER_COURSENAME, $coursename, $text);
    $text = str_replace(PLACEHOLDER_USERMAIL, $usermail, $text);
    $text = str_replace(PLACEHOLDER_USERNAME, $username, $text);
    $text = str_replace(PLACEHOLDER_USERCOUNT, $usercount, $text);
    $text = str_replace(PLACEHOLDER_USERS, $users, $text);

    return $text;
}

/**
 * This function filters the users to recieve a reminder according to the
 * criterias recorded in the database.
 * The criterias are:
 *  - deadline: amount of sec after course enrolment
 *  - groups: user groups specified in the course
 *  - completion status: if users have already completed/not completed the course
 *
 * @param stdClass $entry database entry of block_dukreminder table
 * @return array $users users to recieve a reminder
 */
function block_dukreminder_filter_users($entry) {
    global $DB;
    mtrace("processing reminder $entry->id, subject: $entry->title<br/>"); // Schwed debug
    // All potential users.
    #$users = get_role_users(5, context_course::instance($entry->courseid)); // original
    $users = get_role_users(5, context_course::instance($entry->courseid), '', 'u.id, u.auth, u.username, u.firstname, u.lastname, u.email, u.institution, u.department, u.idnumber, u.address, u.suspended'); // some fields added by G. Schwed

    // START Modification by G. Schwed
    // special for AUA: remove all 'visitors' = persons with role-id = 10
    $visitors = get_role_users(10, context_course::instance($entry->courseid));
    foreach ($visitors as $visitor) {
        mtrace("... unset visitor $visitor->id, $visitor->email<br/>");
        unset($users[$visitor->id]);
    }
    // End AUA special

    // Remove all suspended users, users with nologin and users with email still sent.
    foreach($users as $user) {
        if ($user->auth == "nologin") {
            mtrace("... unset nologin user $user->id, $user->email<br/>");
            unset($users[$user->id]);
        }
        if ($user->suspended == 1) {
            mtrace("... unset suspended user $user->id, $user->email<br/>");
            unset($users[$user->id]);
        }

        // Check if email was already sent to this user.
        #$mailssent = $DB->get_records('block_dukreminder_mailssent', array('reminderid' => $entry->id), '', 'userid', '', 1);
        #if(array_key_exists($user->id, $mailssent)) {
        if ($DB->record_exists('block_dukreminder_mailssent', array('reminderid' => $entry->id, 'userid' => $user->id))) {
            mtrace("... email already sent to user $user->id, $user->email => skipped<br/>");
            unset($users[$user->id]);
        }

        // Check for active enrolment in this course.
        if (!is_enrolled(context_course::instance($entry->courseid), $user, '', TRUE)) {
            mtrace("... user $user->id is suspended => skipped<br>");
            unset($users[$user->id]);
        }
    }

    // Filter users by groups.
    $groupids = explode(';', $entry->to_groups);
    if ($entry->to_groups) {
        foreach ($users as $user) {
            // If user is  part in 1 or more group -> unset.
            $ismember = false;
            foreach ($groupids as $groupid) {
                if (groups_is_member($groupid, $user->id)) {
                    $ismember = true;
                }
            }

            // Unset if user is not at least in one of the selected groups
            // or REVERSE to sent only to persons NOT in selected groups: if($ismember); G. Schwed
            if (!$ismember) { 
                mtrace("... user $user->id not in group => skipped<br/>"); // Schwed debug
                unset($users[$user->id]);
            }
        }
    }

    $count = count($users);
    if ($count == 0) {
        mtrace("=> No users found for reminder $entry->id => nothing to do!<br/>");
        return $users;
    } else {
        mtrace("... => $count potential users found for reminder $entry->id => processing dates and criterias<br/>");
    }

    // Process time and criterias
    // ---------------------------
    // Filter users by absolute date + completion of course or activity.
    if ($entry->dateabsolute > 0) {
        // Course completion.
        if ($entry->criteria == CRITERIA_COMPLETION) {
            foreach ($users as $user) {
                $select = "course = $entry->courseid AND userid = $user->id";
                $timecompleted = $DB->get_field_select('course_completions', 'timecompleted', $select);
                // If user has completed -> unset.
                if (($timecompleted)) {
                #    $timecompleted = date("d.m.Y", $timecompleted);
                    mtrace("... user $user->id: course completed => skipped<br/>"); // Schwed debug
                    unset($users[$user->id]);
                }
            }
        // Activity completion.
        } else if ($entry->criteria != CRITERIA_ALL) { // Criteria (activity) completion.
            $course = $DB->get_record('course', array('id' => $entry->courseid));
            $completion = new completion_info($course);

            // Unset all users if no valid criterias.
            // (Perhaps course criterias have been changed after creating the reminder.)
            if ($DB->get_record('course_completion_criteria', array('id' => $entry->criteria)) === FALSE) {
                mtrace("... ! Error: no or wrong completion criterias ! => reminder skipped<br>"); // Schwed debug
                unset($users);
                $users = array();
                return $users;
            } else {
                // Check for comleted activity
                $criteria = completion_criteria::factory((array)$DB->get_record('course_completion_criteria', array('id' => $entry->criteria)));
                foreach ($users as $user) {
                    $usercompleted = $completion->get_user_completion($user->id, $criteria);
                    if ($usercompleted->is_complete()) {
                        mtrace("... user $user->id: activity completed => skipped<br/>"); // Schwed debug
                        unset($users[$user->id]);
                    }
                }
            }

        }
    }

    // Filter users by relative time + course enrolment
    if ($entry->daterelative > 0 && $entry->criteria == CRITERIA_ENROLMENT) {
        $enabledenrolplugins = implode(',', $DB->get_fieldset_select('enrol', 'id', "courseid = $entry->courseid AND status = 0")); // corrected by G. Schwed 2015-08-05
        #print "enabled enrolment plugins: $enabledenrolplugins<br>"; // Schwed debug

        foreach ($users as $user) {
            // If user has completed the course -> unset.
            $timecompleted = $DB->get_field('course_completions',
                'timecompleted', array('userid' => $user->id, 'course' => $entry->courseid));
            if ($timecompleted > 0) {
                mtrace("... user $user->id; course completed => skipped<br/>"); // Schwed debug
                unset($users[$user->id]);
            }

            // Check user enrolment dates.
            $enrolments = array_values($DB->get_records_select('user_enrolments', "userid = $user->id AND enrolid IN ($enabledenrolplugins)")); // Schwed
            $enrolid = $enrolments[0]->enrolid; // Take just first enrolment method. (Normally it should be 'manual'.)
            $enrolmenttime = $enrolments[0]->timestart;
            // Hack by G. Schwed, because some enrolment plugins still use 'timecreated' instead of 'timestart'.
            if ($enrolmenttime == 0) {
                $enrolmenttime = $enrolments[0]->timecreated;
                mtrace("... user $user->id: 'timestart' = 0 (enrolment $enrolid) => using 'timecreated'<br>");
            }

            // If user is not enrolled long enough -> unset.
            if ($enrolmenttime + $entry->daterelative > time()) {
                mtrace("... user $user->id not enrolled long enough => skipped<br/>"); // Schwed debug
                unset($users[$user->id]);
                continue;
            }

        }
    }

    // Filter users by relative time + course completion.
    if ($entry->daterelative > 0 && $entry->criteria == CRITERIA_COMPLETION) {
        // Check user completion dates.
        foreach ($users as $user) {
            $completiontime = $DB->get_field('course_completions',
                'timecompleted',
                array('userid' => $user->id, 'course' => $entry->courseid));
            // If user completion is not long enough ago -> unset.
            if ($completiontime == FALSE || ($completiontime + $entry->daterelative > time())) { // changed by G. Schwed
                mtrace("... course not completed or deadline not reached for user $user->id => skipped<br/>"); // Schwed debug
                unset($users[$user->id]);
            }
        }
    }

    // Filter users by relative time + activity completion.
    if ($entry->daterelative > 0 && $entry->criteria != CRITERIA_COMPLETION && $entry->criteria != CRITERIA_ENROLMENT) {
        // Check for valid criterias
        // (because perhaps course criterias have been changed after creating the reminder)
        if ($DB->get_record('course_completion_criteria', array('id' => $entry->criteria)) === FALSE) {
            mtrace("... ! Error: no or wrong completion criterias ! => reminder skipped<br>"); // Schwed debug
            // unset all users to skip this reminder
            foreach ($users as $user) {
                unset($users[$user->id]);
            }
            return $users;
        } else {
            $criteria = completion_criteria::factory((array)$DB->get_record('course_completion_criteria', array('id' => $entry->criteria)));
        }

        $course = $DB->get_record('course', array('id' => $entry->courseid));
        $completion = new completion_info($course);
        // Check user completion dates.
        foreach ($users as $user) {
            $usercompleted = $completion->get_user_completion($user->id, $criteria);
            $usercompleted->timecompleted;
            // If user criteria completion is not long enough ago -> unset.
            if (!isset($usercompleted->timecompleted) || ($usercompleted->timecompleted + $entry->daterelative > time())) {
                mtrace("... activity not completed or deadline not reached for user $user->id => skipped<br/>"); // Schwed debug
                unset($users[$user->id]);
            }
        }
    }
    return $users;
}

/**
 * Get manager
 * @param object $user
 * @return boolean
 */
function block_dukreminder_get_manager($user) {
    global $DB;
    // Special function for AUA
    // Bestimme Vorgesetzten (= Manager) zum User
    // Vorgesetzte stehen bei AUA im Adressfeld des Users
    if (strlen($user->address) > 0) { // Wenn Feld nicht leer
        $manager = addslashes(substr($user->address, 0, 50)) . "%"; // addslashes wegen ' in manchen Usernamen
        // Suche userid des Vorgesetzten in mdl_user.
        $select = "idnumber LIKE '$manager'";
        $managerid = $DB->get_field_select('user', 'id', $select);
    } else { // Wenn kein Vorgesetzter im Addressfeld eingetragen
        #$managerid = 2; // Gerhard Schwed Admin, debug
        $managerid = 16543; // = Team Compliance
    }
    // Hole Details des Vorgesetzten aus mdl_user.
    $manager = $DB->get_record('user', array('id' => $managerid)); // G. Schwed
    return $manager; // Schwed
}

/**
 * Replace placeholders
 * @param string $course
 * @param array $users
 * @param boolean $textteacher
 * @return nothing
 */
function block_dukreminder_get_mail_text($course, $users, $textteacher = null) {

    $userlisting = '';
    foreach ($users as $user) {
        $userlisting .= "\n<br>" . fullname($user) . ", $user->email"; // changed by G. Schwed
    }

    // If text_teacher is not set, use lang string (for old reminders).
    if (!$textteacher) {
        $textparams = new stdClass();
        $textparams->amount = count($users);
        $textparams->course = $course;

        $mailtext = get_string('email_teacher_notification', 'block_dukreminder', $textparams);
        $mailtext .= $userlisting;
    } else {
        // If text_teacher is set, use it and replace placeholders.
        $mailtext = block_dukreminder_replace_placeholders($textteacher, $course, '', '', $userlisting, count($users));
        #$mailtext = strip_tags($mailtext); // deactivated by G. Schwed
    }
    return $mailtext;
}

/**
 * Get course teachers
 * @param string $coursecontext
 * @return array
 */
function block_dukreminder_get_course_teachers($coursecontext) {
    return array_merge(get_role_users(4, $coursecontext),
        get_role_users(3, $coursecontext),
        get_role_users(2, $coursecontext),
        get_role_users(1, $coursecontext));
}

/**
 * Get criteria
 * @param string $criteriaid
 * @return string
 */
function block_dukreminder_get_criteria($criteriaid) {
    global $DB;

    if ($criteriaid == CRITERIA_COMPLETION) {
        return get_string('criteria_completion', 'block_dukreminder');
    };
    if ($criteriaid == CRITERIA_ENROLMENT) {
        return get_string('criteria_enrolment', 'block_dukreminder');
    };
    if ($criteriaid == CRITERIA_ALL) {
        return get_string('criteria_all', 'block_dukreminder');
    }

    $completioncriteriaentry = $DB->get_record('course_completion_criteria', array('id' => $criteriaid));
    $mod = new stdClass(); // added by G. Schwed
    if (isset($completioncriteriaentry->module)) $mod = get_coursemodule_from_id($completioncriteriaentry->module, $completioncriteriaentry->moduleinstance); // added by G. Schwed

    return $mod->name;
}
